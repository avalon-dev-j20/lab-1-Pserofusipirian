package ru.avalon.java.j20.labs.models;

import java.util.Iterator;

/**
 * Модель получения последовательности чисел Фибоначчи.
 *
 * <p>Числа Фибонааччи (иногда пишут Фибона́чи[1]) — элементы
 * числовой последовательности 0, 1, 1, 2, 3, 5, 8, 13, 21,
 * 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181,
 * 6765, 10946, 17711, … (последовательность A000045 в OEIS),
 * в которой первые два числа равны либо 1 и 1, либо 0 и 1,
 * а каждое последующее число равно сумме двух предыдущих
 * чисел. Названы в честь средневекового математика Леонардо
 * Пизанского (известного как Фибоначчи).
 *
 * @see <a href="https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D0%BB%D0%B0_%D0%A4%D0%B8%D0%B1%D0%BE%D0%BD%D0%B0%D1%87%D1%87%D0%B8">Числа Фибоначчи</a>
 */
public class Fibonacci implements Iterable<Integer> {
    //Можно было бы сделать все переменные статическими и указать их здесь для обращения к ним
    //из класса FibonacciIterator, но с многопоточностью будут проблемы. И сброс по дефолту придется делать.
    
    //Переменная, содержащая количество чисел последовательности Фибоначчи.
    private int fiboMax;
    
    public Fibonacci(int fiboMax){
        this.fiboMax = fiboMax;
    }
    
    /**
     * Возвращает количество чисел последовательности Фибоначчи.
     */
    public int getFiboNum(){
        return fiboMax;
    }
    /**
     * Итератор, выполняющий обход последовательности
     * чисел Фибоначчи.
     */
    private static class FibonacciIterator implements Iterator<Integer> {
        //Cтатические классы, по идее, существуют в единственном экземпляре. Однако я тестово создавал несколько 
        //классов Fibonacci с разным количеством чисел последовательности, и при их переборе создавался новый
        //экземпляр этого статического класса с вызовом конструктора (именно создавался новый, а не менялся существующий). 
        //Если для статических классов, вложенных в нестатические, правила иные, то не совсем понятно, для чего они нужны 
        //т.е. для чего есть возможность делать их static).
                
        //Переменная, содержащая значение N-2 числа последовательности Фибоначчи.
        private int fiboA = 0;
        //Переменная, содержащая значение N-1 числа последовательности Фибоначчи.       
        private int fiboB = 1;
         //Переменная, содержащая порядковый номер (N) текущего числа последовательности Фибоначчи.       
        private int fiboCurrent = 0;    
        //Переменная, содержащая количество чисел последовательности Фибоначчи.    
        private int fiboMax = 0;
        
        //Так как доступа к нестатическим переменным класса Fibonacci нет, приходится
        //создавать конструктор с параметрами для присваивания значений локальным переменным
        private FibonacciIterator(int fiboMax){
            this.fiboMax = fiboMax;
        }
        
        /**
         * Определяет, есть ли следующее значение
         * последовательности чисел Фибоначчи.
         *
         * @return {@code true}, если следующее число
         * последовательности существует. В обратном случае
         * {@code false}.
         */
        @Override
        public boolean hasNext() {
            return fiboCurrent < fiboMax;
        }

        /**
         * Возвращает следующее число последовательности
         * чисел Фибоначчи.
         *
         * @return следующее число последовательности.
         */
        @Override
        public Integer next() {
            int fiboC = fiboA + (fiboB > fiboCurrent ? 0 : fiboB);
            fiboA = fiboB;
            fiboB = fiboC;
            fiboCurrent++;            
            return fiboC;
        }
    }

    /**
     * Возвращает итератор, позволяющий выполнить обход
     * последовательности чисел Фибоначчи.
     *
     * @return итератор последовательности чисел Фибоначчи
     */
    @Override
    public Iterator<Integer> iterator() {
        return new FibonacciIterator(fiboMax);
    }
}
